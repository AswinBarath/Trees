# Trees 

Problems based on the Tree data structure

## SDE Sheet problems on Trees

[Sheet Link](https://takeuforward.org/interviews/strivers-sde-sheet-top-coding-interview-problems/)

### Day 17 Binary Tree

| Completion Status | Problems on Trees | Explanation | Solution |
| --- | --- | --- | --- |
| âœ… | [Recursive Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/) | [Approach](#in-order-traversal) | [Java Soultion](./src/sde_sheet/Inorder_traversal.java) |
| âœ… | [Recursive Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/) | [Approach](#pre-order-traversal) | [Java Soultion](./src/sde_sheet/Preorder_traversal.java) |
| âœ… | [Recursive Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/) | [Approach](#post-order-traversal) | [Java Soultion](./src/sde_sheet/Postorder_traversal.java) |
| âœ… | [Iterative Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/) | [Approach](#iterative-inorder-traversal) | [Java Soultion](./src/sde_sheet/Inorder_iterative.java) |
| âœ… | [Iterative Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/) | [Approach](#iterative-preorder-traversal) | [Java Soultion](./src/sde_sheet/.java) |
| âœ… | [Iterative Postorder Traversal (Using 2 stacks)](https://leetcode.com/problems/binary-tree-postorder-traversal/) | [Approach](#using-2-stacks) | [Java Soultion](./src/sde_sheet/.java) |
| âœ… | [Iterative Postorder Traversal (Using 1 stack)](https://leetcode.com/problems/binary-tree-postorder-traversal/) | [Approach](#using-1-stack) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [All Traversals in one code](https://leetcode.com/problems/binary-tree-postorder-traversal/) | [Approach](#preorder-inorder-postorder-traversals-in-one-traversal) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Bottom View of Binary Tree](https://practice.geeksforgeeks.org/problems/bottom-view-of-binary-tree/1#) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Top View of Binary Tree](https://practice.geeksforgeeks.org/problems/top-view-of-binary-tree/1) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |

### Day 18 Binary Tree [Continued]

| Completion Status | Problems on Trees | Explanation | Solution |
| --- | --- | --- | --- |
| âœ… | [Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) | [Approach](#level-order-traversal) | [Java Soultion](./src/sde_sheet/Level_order_traversal.java) |
| ðŸ”ƒ | [Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Same Tree](https://leetcode.com/problems/same-tree/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |

### Day 19 Binary Tree [Continued]

| Completion Status | Problems on Trees | Explanation | Solution |
| --- | --- | --- | --- |
| ðŸ”ƒ | [Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |

### Day 20 Binary Search Tree

| Completion Status | Problems on Trees | Explanation | Solution |
| --- | --- | --- | --- |
| ðŸ”ƒ | [Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Lowest Common Ancestor of a BST](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Predecessor and Successor](https://practice.geeksforgeeks.org/problems/predecessor-and-successor/1#) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |

### Day 21 Binary Search Tree [Continued]

| Completion Status | Problems on Trees | Explanation | Solution |
| --- | --- | --- | --- |
| ðŸ”ƒ | [Floor and Ceil from a BST](https://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Kth largest element in BST](https://practice.geeksforgeeks.org/problems/kth-largest-element-in-bst/1) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Two Sum IV - Input is a BST](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Largest BST](https://practice.geeksforgeeks.org/problems/largest-bst/1) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |

### Day 22 Trees [Miscellaneous]

| Completion Status | Problems on Trees | Explanation | Solution |
| --- | --- | --- | --- |
| ðŸ”ƒ | [Binary Tree to DLL](https://practice.geeksforgeeks.org/problems/binary-tree-to-dll/1#) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Distinct Numbers in Window](https://www.interviewbit.com/problems/distinct-numbers-in-window/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |
| ðŸ”ƒ | [Flood Fill](https://leetcode.com/problems/flood-fill/) | [Brute, Better & Optimal Approaches](#) | [Java Soultion](./src/sde_sheet/.java) |

---

## In-order traversal

- Inorder traversal is a depth-first traversal type
- In inorder traversal we follow the `Left - Root - Right` pattern to traverse the nodes of the binary tree
- So, for each traversal we go to the leftmost node then the root and then the rightmost node
- If we have a Binary tree of height more than 2, we treat each segment of the left and right of the root of binary tree as subtrees. 
- Hence until we traverse in-depth at left subtree we won't visit the root and right subtree.
- Java Code (Recursive)
```
	public static void inorder_traversal(Node root) {
		if (root == null)
			return;

		inorder_traversal(root.left);
		System.out.print(root.data + " ");
		inorder_traversal(root.right);
	}
```

## Pre-order traversal

- Preorder traversal is a depth-first traversal type
- In preorder traversal we follow the `Root - Left - Right` pattern to traverse the nodes of the binary tree
- So, for each traversal we go to the root, then leftmost node then the rightmost node
- If we have a Binary tree of height more than 2, we treat each segment of the left and right of the root of binary tree as subtrees. 
- Hence until we traverse the root we won't visit the left subtree and right subtree.
- Java Code (Recursive)
```
	public static void preorder_traversal(Node root) {
		if (root == null)
			return;

		System.out.print(root.data + " ");
		preorder_traversal(root.left);
		preorder_traversal(root.right);
	}
```

## Post-order traversal

- Postorder traversal is a depth-first traversal type
- In postorder traversal we follow the `Left - Right - Root` pattern to traverse the nodes of the binary tree
- So, for each traversal we go the leftmost node and then the rightmost node only then the root
- If we have a Binary tree of height more than 2, we treat each segment of the left and right of the root of binary tree as subtrees. 
- Hence until we traverse in-depth at left subtree and right subtree we won't visit the root.
- Java Code (Recursive)
```
	public static void postorder_traversal(Node root) {
		if (root == null)
			return;

		postorder_traversal(root.left);
		postorder_traversal(root.right);
		System.out.print(root.data + " ");
	}
```

<p>
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Preorder-from-Inorder-and-Postorder-traversals.jpg" alt="Traversal Techniques" width="400px" />
</p>

---

## Level-order traversal

- Levelorder traversal is a breadth-first traversal type
- In levelorder traversal we visit each node of the binary tree on a level-wise pattern
- So, for each traversal we go to each level visiting the nodes from `left to right`
- Here's a pictorial understanding of all of the above traversals

<p>
<img src="https://examradar.com/wp-content/uploads/2016/10/pre-post-inorder-and-level-order.png" alt="Traversal Techniques" width="400px" />
</p>

**Code Explanation**

- To store a given level, we can use **queue** data structure
- To store level wise order we can use **List of List** data structure where we store a level in a List and store all lists of levels as a list inside this data structure
- For every level we visit,
	- we will first insert it into the queue
	- next, we take the nodes of current level and check its left and right
	- If left and right exists, we insert the current level of nodes as list inside the answer data structure 
	- and insert the left and right we checked into the queue data structure
	- Repeat until left and right is null

**Dry Run**

<img src="assets/Level order traversal dry run.jpg" alt="Level order traversal dry run" width="400px" />

---

## Iterative preorder traversal

- We use **root** variable to store current node
- Use Arraylist **inorder** to store inorder traversal answer
- And a Stack **stack** to store left and right of current nodes
- Insert the root node inside stack first
- Traversal begins
	- Pop the top most node and store it in **root** variable
	- Store the value of **root** inside **inorder** list
	- Using **root**
		- check if right of **root** exists and push into stack
		- check if left of **root** exists and push into stack
	- Continue traversal until stack is empty
- Return **inorder** list

**Dry Run**

<img src="assets/Iterative preorder traversal dry run.jpg" alt="Iterative preorder traversal dry run" width="400px" />

---

## Iterative inorder traversal

- We use **node** variable to store current node
- Use Arraylist **inorder** to store inorder traversal answer
- And a Stack **stack** to simulate the auxiliary stack trace used in recursion
- Now the traversal begines
	- *If* **node** is not null, push to stack and go the left of **node**
	- *Else* check once whether stack is empty
	- *Then* if **node** is null, do 2 things
		- Print answer  (or) insert the current **node**'s value to answer
		- And go to right of **node**
	- Repeat the traversal steps until the stack is empty
- Return answer

**Dry Run**

<img src="assets/Iterative inorder traversal dry run.jpg" alt="Iterative inorder traversal dry run" width="400px" />

---

## Iterative postorder traversal

- There are two approaches to iteratively apply postorder traversal: (1) Using 2 stacks & (2) Using 1 stack

### Using 2 stacks

- Initially insert root in **stack 1**
- Traversal begins:
	- Take the topmost node from **stack 1** to insert in **stack 2**
	- Now, for the topmost node of **stack 2**, insert left and right in to **stack 1**
- Once **stack 1** is empty, print/return **stack 2* nodes in LIFO order. That's the answer.
- Observation: 
	- We try insert root nodes @ **stack 2**
	- followed by right nodes @ **stack 2**
	- followed by left nodes @ **stack 2**
	- In this way we get the correct postorder in **stack 2**
	- So the **stack 2** takes input in reverse of postorder and outputs correct postorder

**Dry Run**

<img src="assets/Iterative postorder traversal using 2 stacks dry run.jpg" alt="Iterative postorder traversal using 2 stacks dry run" width="400px" />

---

### Using 1 stack

- At first the root is inserted into the **stack**
- Take a variable **cur** to keep track of left nodes
- First we traverse to the left-most node and insert every node we visit in the travsersal into the **stack**. Basically we are insert every left node from the left subtree.
- Next, when we reach the leftmost node, the **cur** will become null
- Now, create another variable **temp** to keep track of the right nodes
- Whenever we reach a leaf node:
	- we pop the top node from **stack** and add it to postorder
	- Now, we also check whether the popped node (still stored in **temp**) was right node. If yes, we pop the top node from **stack** again and add it postorder. We repeat this step until all root nodes of popped nodes are added to postorder.
- Return the answer

**Dry Run**

<img src="assets/Iterative postorder traversal using 1 stack dry run 1.jpg" alt="Iterative postorder traversal using 1 stack dry run 1" width="400px" />

<img src="assets/Iterative postorder traversal using 1 stack dry run 2.jpg" alt="Iterative postorder traversal using 1 stack dry run 2" width="400px" />

## Preorder Inorder Postorder Traversals in One Traversal

- 


---
---

## Notes on Tree Data Structure

- Trees are hierarchical data structures, compared with Arrays, Stacks, Queues, Linked lists which are linear data structures
- A hierarchy can be observed in our folder structure

---

### Key terminologies of a tree

<p>
<img src="https://miro.medium.com/max/975/1*PWJiwTxRdQy8A_Y0hAv5Eg.png" alt="Tree data structure" width="400px" />
</p>


---

## Introduction to Binary Trees

- A tree which can contain at max only two nodes as children is a **Binary Tree**
- Maximum number of nodes at level i is `2^i`
- Maximum number of nodes in a binary tree with height h is `2^h - 1`
- *Note: Levels in trees start with number 0 and height starts with 1*

<img src="assets/Binary Tree in Array Implementation.png" alt="Binary Tree in Array Implementation" width="400px" />

---

## Traversal Techniques (BFS | DFS)

- Depth-first search (DFS) - Inorder Traversal, Preorder Traversal, Postorder Traversal 

### Inorder Traversal 
- Left - Root - Right 

### Preorder Traversal 
- Root - Left - Right 

### Postorder Traversal 
- Left - Right - Root 

<hr />
<p>
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Preorder-from-Inorder-and-Postorder-traversals.jpg" alt="Traversal Techniques" />
</p>
<hr />

- Breadth-first Search (BFS) - Level Order Traversal 

<hr />
<p>
<img src="https://examradar.com/wp-content/uploads/2016/10/pre-post-inorder-and-level-order.png" alt="Traversal Techniques" />
</p>
<hr />

## Types of Trees

1. Generic Tree
2. Binary Tree
3. [Binary Search Tree](https://www.programiz.com/dsa/binary-search-tree)
4. [AVL Tree](https://www.programiz.com/dsa/avl-tree)
5. [Red-Black Tree](https://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/)
6. [N-ary Tree](https://www.studytonight.com/advanced-data-structures/nary-tree#:~:text=The%20N%2Dary%20tree%20is,children%20of%20a%20particular%20node.)
7. [Segment Tree](https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/)
8. [B-tree](https://www.programiz.com/dsa/b-tree)


---


## 1. Generic Tree

- A generic tree is a tree which any node can have any number of children

---

### Types of Binary Trees

<p>
<img src="https://miro.medium.com/max/16000/1*CMGFtehu01ZEBgzHG71sMg.png" alt="Types of tree data structure" />
</p>

#### 1. Full Binary Tree
- Every node in this tree will either have 0 or 2 children
- Example of Full Binary Tree
<p>
<img src="https://web.cecs.pdx.edu/~sheard/course/Cs163/Graphics/FullBinary.jpg" alt="Full Binary Tree data structure" />
</p>

#### 2. Complete Binary Tree
- All levels are completely filled except the last level
- The last level has all nodes as left as possible
- Example of Complete Binary Tree
<p>
<img src="https://www.techiedelight.com/wp-content/uploads/Complete-Binary-Tree.png" alt="Complete Binary Tree data structure" />
</p>

#### 3. Perfect Binary Tree
- All leaf are at the same level
- Examples of Perfect Binary Tree
<p>
<img src="https://cdn.programiz.com/sites/tutorial2program/files/perfect-binary-tree-rec.png" alt="Perfect Binary Tree data structure" />
</p>
<p>
<img src="https://adrianmejia.com/images/full-complete-perfect-binary-tree.jpg" alt="Perfect Binary Tree data structure" />
</p>
<p>
<img src="https://codepumpkin.com/wp-content/uploads/2018/08/Perfect_Binary_Tree.jpg" alt="Perfect Binary Tree data structure" />
</p>

#### 4. Balanced Binary Tree
- The height of the tree should be at maximum of Log(N), where N is no. of nodes
- Examples of Balanced Binary Tree
<p>
<img src="https://codepumpkin.com/wp-content/uploads/2018/08/Balanced_Binary_Tree.jpg" alt="Balanced Binary Tree data structure" />
</p>
<p>
<img src="https://i.stack.imgur.com/n2CFS.png" alt="Balanced Binary Tree data structure" />
</p>

#### 5. Degenerate/ Skewed Binary Tree
- A binary tree, which is dominated solely by left child nodes or right child nodes, is called a skewed binary tree, more specifically left skewed binary tree, or right skewed binary tree.
- Examples of Degenerate/ Skewed Binary Tree
<p>
<img src="https://www.gatevidyalay.com/wp-content/uploads/2018/07/Skewed-Binary-Tree-Example.png" alt="Degenerate/ Skewed Binary Tree data structure" />
</p>
<p>
<img src="https://codepumpkin.com/wp-content/uploads/2018/08/Left_Right_Skewed_Tree.jpg" alt="Degenerate/ Skewed Binary Tree data structure" />
</p>
<hr />
<p>
<img src="https://d2uusema5elisf.cloudfront.net/books/javascript-algorithms/images/06-binary-search-tree/binary-tree-types.png" alt="Binary Tree data structure" />
</p>
<hr />
